---
title: Yet Another Smacof
  - Square Symmetric Case
author: 
      name: Jan de Leeuw
      orcid: 0000-0003-1420-1797
      email: jan@deleeuwpdx.net
      affiliation: 
        - name: University of California Los Angeles
          city: Los Angeles
          state: CA
          url: www.ucla.edu
      license: "CC0"
date: last-modified
date-format: long
bibliography: [mypubs.bib, total.bib]
number-sections: true
pdf-engine: lualatex
keep-tex: true
format:
   pdf:
    fontsize: 12pt
    include-in-header: 
     - preamble.tex
    keep-tex: true
    link-citations: true
    documentclass: scrartcl
    number-sections: true
   html:
    fontsize: 12pt
    include-in-header: 
     - preamble.css
    keep-md: true
    number-sections: true
toc: true
toc-depth: 3
editor: source
papersize: letter
graphics: true
link-citations: true
mainfont: Times New Roman
abstract: We rewrite the metric/nonmetric and weighted/unweighted versions of the smacof program for   square symmetric data as four monolithic C programs, with R used for taking care of the setup, the    I/O, and of issuing a single call to .C() to start the computations. This makes the programs twenty to fifty times as fast (for our examples) as the smacofSym() function from the smacof package.
---

```{r loadpackages, echo = FALSE}
suppressPackageStartupMessages(library(knitr, quietly = TRUE))
suppressPackageStartupMessages(library(tinytex, quietly = TRUE))
suppressPackageStartupMessages(library(microbenchmark, quietly = TRUE))
suppressPackageStartupMessages(library(smacof, quietly = TRUE))
```

```{r loadsourses, echo = FALSE}
source("smacofUtils.R")
source("smacofSSUR.R")
source("smacofSSWR.R")
source("smacofSSUO.R")
source("smacofSSWO.R")
```

```{r turnoff, echo = FALSE}
options(warn = -1)
```

**Note:** This is a working manuscript which will be expanded/updated
frequently. All suggestions for improvement are welcome. All Rmd, tex,
html, pdf, R, and C files are in the public domain. Attribution will be
appreciated, but is not required. The files can be found at
<https://github.com/deleeuw/smacofFlat> 

\sectionbreak

# Introduction

The data in MDS is qualitative or quantitative information about the *dissimilarities* $\delta_k$ between $m$ pairs of objects $(i,j)$, with the objects coming from a set of $n$ objects. The information about the dissimilarities is of the form $\delta\in\Delta$, where $\Delta$ is a known subset of the non-negative orthant of $\mathbb{R}^m$. In MDS we want to map the objects into points in $p$-dimensional Euclidean space in such a way that the distances $d_k$ between the points approximate the dissimilarities $\delta_k$. If the dissimilarities are known numbers and $\Delta$ has only a single element the MDS problem is *metric*, in all other cases the problem is *non-metric*.

The quality of the approximation is given by the least squares loss function\footnote{The symbol $:=$ is used for definitions.}
\begin{equation}
\sigma(X,\Delta):=\frac{\sum_{k=1}^mw_k(\delta_k-d_k(X))^2}{\sum_{k=1}^mw_k\delta_k^2},
\label{eq-stressdef}
\end{equation}
Traditionally, this loss function is called *stress* (@kruskal_64a, @kruskal_64b).

In definition \eqref{eq-stressdef}

* $\delta_k$ are $m$ non-negative *pseudo-distances*;
* $w_k$ are $m$ positive *weights*;
* $X$ is an $n\times p$ *configuration*, with coordinates of $n$ *points* in $\mathbb{R}^p$;
* $d_k(X)$ are the (Euclidean) *distances* between the rows of the configuration matrix.

The (unconstrained, least squares, square, symmetric, Euclidean, $p-$dimensional) MDS problem is to minimize $\sigma$ of \eqref{eq-stressdef} over all $n\times p$ configurations and over the set $\Delta\in\mathbb{R}^m_+$ of non-negative pseudo-distances. 

\sectionbreak

# MDS Data Structure

Start with an object of class *dist* containing dissimilarities. Here is a small example of order four.
```{r small, echo = FALSE}
small <- as.dist(matrix(
  c(0, 1, 3, 2, 1, 0, 1, 3, 3, 1, 0, 1, 2, 3, 1, 0), 4, 4))
print(small)
```
Turn this into MDS data with the utility makeMDSData().
```{r smalldata}
smallData <- makeMDSData(small)
print(smallData)
```
Note that the data in column *delta* are increasing, and that *blocks* has tie blocks. Also, the *weights* are always there in some form or another, even for MDS analyses that are unweighted (i.e. when all $w_k$ are equal).

makeMDSData() can handle missing data and nontrivial weights. If our example is
```{r smallmis, echo = FALSE}
smallMissing <- small
smallMissing[1] <- smallMissing[3] <- NA
print(smallMissing) 
```
and we add weights, also of class *dist*,
```{r smallweights, echo = FALSE}
smallWeights <- as.dist(matrix(c(0, 1, 1, 2, 1, 0, 3, 1, 1, 3, 0, 0, 2, 1,0, 0 ), 4, 4))
print(smallWeights)
```
then our MDS data becomes
```{r smalldatamis}
smallData <- makeMDSData(smallMissing, smallWeights)
print(smallData)
```
Missing data are coded as zero weights, or as dissimilarities and/or weights that are *NA*.
Zero dissimilarities do not indicate missing data.

These conventions make it possible to also handle rectangular off-diagonal data, such as
```{r rect, echo = FALSE}
m <- matrix(c(1, 3, 1, 1, 2, 1, 3, 3, 3, 1, 2, 3), 4, 3)
rect <- matrix(0, 7, 7)
rect[1:4, 5:7] <- m
rect <- as.dist(rect + t(rect))
weights <- matrix(0, 7, 7)
weights[1:4, 5:7] <- 1
weights <- as.dist(weights + t(weights))
print(rect)
print(weights)
```
Now *makeMDSData* gives
```{r rectdata, echo = FALSE}
rectData <- makeMDSData(rect, weights)
print(rectData)
```
Handling rectangular data with square symmetric MDS is inefficient
and it is better to use the smacof programs specifically intended for rectangular data.

It is of course also possible to construct MDS data sets of this form in other ways, and to edit
the MDS data sets generated by makeMDSData(). As long as the conventions are obeyed that no index pair $(i,j)$ occurs more than once, that the dissimilarities are sorted, and that the tie blocks faithfully reflect ties in the sorted dissimilarities. We do need $i\neq j$, but it is not necessary that always $i>j$.

\sectionbreak

# Arguments

The smacofSS() function has the following arguments, with default values

1. *theData*, an MDS data structure.  
2. *ndim=2*, dimensionality of MDS analysis.
3. *xinit=torgerson(theData, ndim)*, initial configuration, an *nobj* by *ndim* matrix.
4. *weighted = FALSE*, TRUE/FALSE for weighted/unweighted least squares.
5. *ordinal = FALSE*, FALSE or 0 for numerical, 1,2,3 for ordinal.
6. *itmax = 1000*, maximum number of iterations.
7. *eps = 1e-10*, if loss changes less than *eps*, stop.
8. *digits = 10*, digits stress print if verbose is TRUE,
9. *width = 12*, width stress print if verbose is TRUE,
10. *verbose = FALSE*, TRUE/FALSE print stress for each iteration to *stdout*.

In *ordinal* we use 1 for the primary approach to ties, 2 for the secondary
approach, and 3 for the tertiary approach (@deleeuw_A_77). The default
initial configuration is the classical scaling solution, with missing
data imputed as average non-missing dissimilarities.

smacofSS() is a front end that reads the parameters of the problem and then calls
one of four separate R programs. They are 

1. smacofSSUR(), unweighted numerical;
2. smacofSSWR(), weighted numerical;
3. smacofSSUO(), unweighted ordinal;
4. smacofSSWO(), weighted ordinal.

Although using four separate programs involves duplicating some code it does
allow us to make the programs smaller and faster. For example, we are not have to do
weighted updates with unit weights in the unweighted case, and we don't have to 
branch each time for either ordinal and numerical.

Each of the four R programs calls a corresponding shared library, called smacofSSUREngine.so,
smacofSSWREngine.so, smacofSSUOEngine.so, and smacofSSWOEngine.so which contain,
respectively, the compiled code of the four C routines smacofSSUREngine(),
smacofSSWREngine(), smacofSSUOEngine(), and smacofSSWOEngine().

Each of the four R programs can also be called directly, without using the smacofSS()
frontend. Their arguments are the same as for smacofSS(), except that *weighted* and *ordinal* are
not there, while smacofSSUO() and smacofSSWO() have the additional argument *ties*,
equal to 1 (default), 2, or 3.

\sectionbreak

# Details

The C routines by themselves are complete smacof MDS programs. It is easy to write main programs
in C that do the same job as the R frontend, and compile to stand-alone compiled executables.
The C code uses the .C() calling conventions and is otherwise not dependent on R in any way. 
I may actually do this sometime.

It is important that the .C() call from R is only executed once in smacofSS(), when loading the
shared library, and after that call it is all compiled code running until the end of the job. 
In other words, everything done in R is eithert front end or back end, and is only done once.
Earlier versions of the R/C program had R managing the iterations. In each iteration there was a .C() call to update the configation and in the ordinal case an additional .C() call to update
the pseudo-distances. This turned out to be rather unsatisfactory, because it did
not give a substantial speedup compared to smacofSym() in the R smacof
package (@deleeuw_mair_A_09c, @mair_groenen_deleeuw_A_22).

If *ordinal* is TRUE the monotone regression in each iteration
uses the C version of the *monotone()* algorithm of @busing_22. The *monotone()*
algorithm is imbedded in three separate C routines *primaryApproach()*, *secondaryApproach()*,
and *tertiaryApproach()*. 

The default initial configuration is computed by the 
*torgerson()* routine in *smacofUtils.R*. This is classical MDS, with the missing
dissimilarities imputed using the average non-missing dissimilarity. The
eigenvalues and eigenvectors are computed with *eigs-sym()* from the
*RSpectra* package (@qiu_mei_24).

\sectionbreak


# Value

1. *theData*.
2. *dhat*, final pseudo-distances.
3. *confdist*, final distances.
4. *conf*, final configuration.
5. *stress*, final stress.
6. *ndim*, number of dimensions.
7.  *init*, initial configuration.
8.  *niter*, number of iterations.
9.  *nobj*, number of objects.
10. *weighted*, was the analysis weighted.
11. *ordinal*, was the analysis ordinal (and if so, which tie approach).

One thing should be kept in mind. In the ordinal case, with the primary approach to ties, the data
are reordered within tie blocks in each iteration. In the MDS data structure we reorder iind, jind,
and in the weighted case the weights. There is no need to reorder delta and the blocks, because the
only ordering changes are within blocks. No reordering is going on in the secondary and tertiary
approaches.


\sectionbreak

# Utilities

## Plotting

## I/O

# Example Data Sets

ekman
rthkopf
degruijter
wish
iris






\sectionbreak

# Comparisons

## Outcome

```{r}
source("smacofSSData/morseData.R")
xinit <- torgerson(morseData, 2)
```

```{r compUR, cache = FALSE, echo = FALSE}
h1 <- smacofSym(morse, init = xinit, type = "ratio", eps = 1e-10, itmax = 1000)
h2 <- smacofSSUR(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, verbose = FALSE)
cat(formatC(h1$stress ^ 2, digits = 10, width = 15, format = "f"),
    formatC(h1$niter, width = 6, format = "d"),
    formatC(h2$loss, digits = 10, width = 15, format = "f"),
    formatC(h2$itel, width = 6, format = "d"),"\n")
```

```{r compUO1, cache = FALSE, echo = FALSE}
h1 <- smacofSym(morse, type = "ordinal", ties = "primary", eps = 1e-10, itmax = 1000)
h2 <- smacofSSUO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 1, verbose = FALSE)
cat(formatC(h1$stress ^ 2, digits = 10, width = 15, format = "f"),
    formatC(h1$niter, width = 6, format = "d"),
    formatC(h2$loss, digits = 10, width = 15, format = "f"),
    formatC(h2$itel, width = 6, format = "d"),"\n")
```
```{r compUO2, cache = FALSE, echo = FALSE}
h1 <- smacofSym(morse, type = "ordinal", ties = "secondary", eps = 1e-10, itmax = 1000)
h2 <- smacofSSUO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 2, verbose = FALSE)
cat(formatC(h1$stress ^ 2, digits = 10, width = 15, format = "f"),
    formatC(h1$niter, width = 6, format = "d"),
    formatC(h2$loss, digits = 10, width = 15, format = "f"),
    formatC(h2$itel, width = 6, format = "d"),"\n")
```
```{r compUO3, cache = FALSE, echo = FALSE}
h1 <- smacofSym(morse, type = "ordinal", ties = "tertiary", eps = 1e-10, itmax = 1000)
h2 <- smacofSSUO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 3, verbose = FALSE)
cat(formatC(h1$stress ^ 2, digits = 10, width = 15, format = "f"),
    formatC(h1$niter, width = 6, format = "d"),
    formatC(h2$loss, digits = 10, width = 15, format = "f"),
    formatC(h2$itel, width = 6, format = "d"),"\n")
```

```{r compWR, cache = FALSE, echo = FALSE}
h1 <- smacofSym(morse, type = "ratio", eps = 1e-10, weightmat = 1 / morse, itmax = 1000)
h2 <- smacofSSWR(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, verbose = FALSE)
cat(formatC(h1$stress ^ 2, digits = 10, width = 15, format = "f"),
    formatC(h1$niter, width = 6, format = "d"),
    formatC(h2$loss, digits = 10, width = 15, format = "f"),
    formatC(h2$itel, width = 6, format = "d"),"\n")
```

```{r compWO1, cache = FALSE, echo = FALSE}
h1 <- smacofSym(morse, type = "ordinal", ties = "primary", weightmat = 1 / morse, eps = 1e-10, itmax = 1000)
h2 <- smacofSSWO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 1, verbose = FALSE)
cat(formatC(h1$stress ^ 2, digits = 10, width = 15, format = "f"),
    formatC(h1$niter, width = 6, format = "d"),
    formatC(h2$loss, digits = 10, width = 15, format = "f"),
    formatC(h2$itel, width = 6, format = "d"),"\n")
```
```{r compWO2, cache = FALSE, echo = FALSE}
h1 <- smacofSym(morse, type = "ordinal", ties = "secondary", weightmat = 1 / morse, eps = 1e-10, itmax = 1000)
h2 <- smacofSSWO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 2, verbose = FALSE)
hh <- c(h1$stress, h1$niter, h2$loss, h2$itel)
cat(formatC(h1$stress ^ 2, digits = 10, width = 15, format = "f"),
    formatC(h1$niter, width = 6, format = "d"),
    formatC(h2$loss, digits = 10, width = 15, format = "f"),
    formatC(h2$itel, width = 6, format = "d"),"\n")
```
```{r compWO3, cache = FALSE, echo = FALSE}
h1 <- smacofSym(morse, type = "ordinal", ties = "tertiary", weightmat = 1 / morse, eps = 1e-10, itmax = 1000)
h2 <- smacofSSWO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 3, verbose = FALSE)
cat(formatC(h1$stress ^ 2, digits = 10, width = 15, format = "f"),
    formatC(h1$niter, width = 6, format = "d"),
    formatC(h2$loss, digits = 10, width = 15, format = "f"),
    formatC(h2$itel, width = 6, format = "d"),"\n")
```

## Time

```{r microbenchmark_num, cache = TRUE, echo = FALSE}
microbenchmark(
smacofSym(morse, type = "ratio", eps = 1e-10, itmax = 1000),
smacofSSUR(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, verbose = FALSE), control = list(order = "inorder"))
```

```{r microbenchmark_ord1, cache = TRUE, echo = FALSE}
microbenchmark(
smacofSym(morse, type = "ordinal", ties = "primary", eps = 1e-10, itmax = 1000),
smacofSSUO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 1, verbose = FALSE), control = list(order = "inorder"))
```
```{r microbenchmark_ord2, cache = TRUE, echo = FALSE}
microbenchmark(
smacofSym(morse, type = "ordinal", ties = "secondary", eps = 1e-10, itmax = 1000),
smacofSSUO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 2, verbose = FALSE), control = list(order = "inorder"))
```
```{r microbenchmark_ord3, cache = TRUE, echo = FALSE}
microbenchmark(
smacofSym(morse, type = "ordinal", ties = "tertiary", eps = 1e-10, itmax = 1000),
smacofSSUO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 3, verbose = FALSE), control = list(order = "inorder"))
```



```{r wgthnum, cache = TRUE, echo = FALSE}
microbenchmark(
smacofSym(morse, type = "ratio", eps = 1e-10, weightmat = 1 / morse, itmax = 1000),
smacofSSWR(morseData, ndim = 2,  xinit = xinit, eps = 1e-10, itmax = 1000, verbose = FALSE), control = list(order = "inorder"))
```

```{r wgthord1, cache = TRUE, echo = FALSE}
microbenchmark(
smacofSym(morse, type = "ordinal", ties = "primary", eps = 1e-10, weightmat = 1 / morse, itmax = 1000),
smacofSSWO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 1, verbose = FALSE), control = list(order = "inorder"))
```

```{r wgthord2, cache = TRUE, echo = FALSE}
microbenchmark(
smacofSym(morse, type = "ordinal", ties = "secondary", eps = 1e-10, weightmat = 1 / morse, itmax = 1000),
smacofSSWO(
  morseData,
  ndim = 2,
  xinit = xinit,
  eps = 1e-10,
  itmax = 1000,
  ties = 2,
  verbose = FALSE
), control = list(order = "inorder"))
```
```{r wgthord3, cache = TRUE, echo = TRUE}
microbenchmark(
smacofSym(morse, type = "ordinal", ties = "tertiary", eps = 1e-10, weightmat = 1 / morse, itmax = 1000),
smacofSSWO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 3, verbose = FALSE), control = list(order = "inorder"))
```
```{r table, echo = FALSE}
rnames = c(
"ratio, unweighted",
"ordinal, unweighted,ties = primary",
"ordinal, unweighted, ties = secondary",
"ordinal, unweighted, ties = tertiary"
)
x = matrix(c(
15156.388,850.504, 15156.38/850.504,
14956.0825, 382.8785, 14956.0825/382.8785,
9977.2885, 342.2475, 9977.2885/342.2475,
24522.2640, 365.9045, 24522.2640/365.9045
), 4, 3, byrow = TRUE)
x <- data.frame(rnames, as.data.frame(x))
kable(x, digits = 4, row.names = FALSE, col.names = c("options", "smacofSym", "smacofSS", "ratio"))
```

```{r iristime, cache = TRUE}
microbenchmark(
smacofSym(irisDist, eps = 1e-10, verbose = FALSE, type = "ratio", itmax = 1000),
smacofSSUR(irisData, verbose = FALSE))
```

\sectionbreak


# References