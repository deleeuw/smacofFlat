---
title: Yet Another Smacof
  - Square Symmetric Case
author: 
      name: Jan de Leeuw
      orcid: 0000-0003-1420-1797
      email: jan@deleeuwpdx.net
      affiliation: 
        - name: University of California Los Angeles
          city: Los Angeles
          state: CA
          url: www.ucla.edu
      license: "CC0"
date: last-modified
date-format: long
bibliography: [mypubs.bib, total.bib]
number-sections: true
pdf-engine: lualatex
keep-tex: true
format:
   pdf:
    fontsize: 12pt
    include-in-header: 
     - preamble.tex
    keep-tex: true
    link-citations: true
    documentclass: scrartcl
    number-sections: true
   html:
    fontsize: 12pt
    include-in-header: 
     - preamble.css
    keep-md: true
    number-sections: true
toc: true
toc-depth: 3
editor: source
papersize: letter
graphics: true
link-citations: true
mainfont: Times New Roman
abstract: We rewrite the metric/nonmetric and weighted/unweighted versions of the smacof program for   square symmetric data as four monolithic C programs, with R used for taking care of the setup, the    I/O, and of issuing a single call to .C() to start the computations. This makes the programs five to fifteen times as fast (for our examples) as the smacofSym() function from the R smacof package.
---

```{r loadpackages, echo = FALSE}
suppressPackageStartupMessages(library(knitr, quietly = TRUE))
suppressPackageStartupMessages(library(tinytex, quietly = TRUE))
suppressPackageStartupMessages(library(microbenchmark, quietly = TRUE))
suppressPackageStartupMessages(library(smacof, quietly = TRUE))
```

```{r loadsourses, echo = FALSE}
source("smacofDataUtilities.R")
source("smacofAuxiliaries.R")
source("smacofPlots.R")
source("smacofSS.R")
source("smacofSSUR.R")
source("smacofSSWR.R")
source("smacofSSUO.R")
source("smacofSSWO.R")
```

```{r turnoff, echo = FALSE}
options(warn = -1)
```

**Note:** This is a working manuscript which will be expanded/updated frequently. All suggestions for improvement are welcome. All Rmd, tex, html, pdf, R, and C files are in the public domain. Attribution will be appreciated, but is not required. The files can be found at <https://github.com/deleeuw/smacofFlat>

\sectionbreak

# Introduction

The data in MDS is qualitative or quantitative information about the *dissimilarities* $\delta_k$ between $m$ pairs of objects $(i,j)$, with the objects coming from a set of $n$ objects. The information about the dissimilarities is of the form $\delta\in\Delta$, where $\Delta$ is a known subset of the non-negative orthant of $\mathbb{R}^m$. In MDS we want to map the objects into points in $p$-dimensional Euclidean space in such a way that the distances $d_k$ between the points approximate the dissimilarities $\delta_k$. If the dissimilarities are known numbers and $\Delta$ has only a single element the MDS problem is *metric*, in all other cases the problem is *non-metric*.

The quality of the approximation is given by the least squares loss function\footnote{The symbol $:=$ is used for definitions.} \begin{equation}
\sigma(X,\Delta):=\frac{\sum_{k=1}^mw_k(\delta_k-d_k(X))^2}{\sum_{k=1}^mw_k\delta_k^2},
\label{eq-stressdef}
\end{equation} Traditionally, this loss function is called *stress* (@kruskal_64a, @kruskal_64b).

In definition \eqref{eq-stressdef}

-   $\delta_k$ are $m$ non-negative *pseudo-distances*;
-   $w_k$ are $m$ positive *weights*;
-   $X$ is an $n\times p$ *configuration*, with coordinates of $n$ *points* in $\mathbb{R}^p$;
-   $d_k(X)$ are the (Euclidean) *distances* between the rows of the configuration matrix.

The (unconstrained, least squares, square, symmetric, Euclidean, $p-$dimensional) MDS problem is to minimize $\sigma$ of \eqref{eq-stressdef} over all $n\times p$ configurations and over the set $\Delta\in\mathbb{R}^m_+$ of non-negative pseudo-distances.

\sectionbreak

# MDS Data Structure

Start with an object of class *dist* containing dissimilarities. Here is a small example of order four.

```{r small, echo = FALSE}
small <- as.dist(matrix(
  c(0, 1, 3, 2, 1, 0, 1, 3, 3, 1, 0, 1, 2, 3, 1, 0), 4, 4))
print(small)
```

Turn this into MDS data with the utility makeMDSData().

```{r smalldata}
smallData <- makeMDSData(small)
print(smallData)
```

Note that the data in column *delta* are increasing, and that *blocks* has tie blocks. Also, the *weights* are always there in some form or another, even for MDS analyses that are unweighted (i.e. when all $w_k$ are equal).

makeMDSData() can handle missing data and nontrivial weights. If our example is

```{r smallmis, echo = FALSE}
smallMissing <- small
smallMissing[1] <- smallMissing[3] <- NA
print(smallMissing) 
```

and we add weights, also of class *dist*,

```{r smallweights, echo = FALSE}
smallWeights <- as.dist(matrix(c(0, 1, 1, 2, 1, 0, 3, 1, 1, 3, 0, 0, 2, 1,0, 0 ), 4, 4))
print(smallWeights)
```

then our MDS data becomes

```{r smalldatamis}
smallData <- makeMDSData(smallMissing, smallWeights)
print(smallData)
```

Missing data are coded as zero weights, or as dissimilarities and/or weights that are *NA*. Zero dissimilarities do not indicate missing data.

These conventions make it possible to also handle rectangular off-diagonal data, such as

```{r rect, echo = FALSE}
m <- matrix(c(1, 3, 1, 1, 2, 1, 3, 3, 3, 1, 2, 3), 4, 3)
rect <- matrix(0, 7, 7)
rect[1:4, 5:7] <- m
rect <- as.dist(rect + t(rect))
weights <- matrix(0, 7, 7)
weights[1:4, 5:7] <- 1
weights <- as.dist(weights + t(weights))
print(rect)
print(weights)
```

Now *makeMDSData* gives

```{r rectdata, echo = FALSE}
rectData <- makeMDSData(rect, weights)
print(rectData)
```

Handling rectangular data with square symmetric MDS is inefficient and it is better to use the smacof programs specifically intended for rectangular data.

It is of course also possible to construct MDS data sets of this form in other ways, and to edit the MDS data sets generated by makeMDSData(). As long as the conventions are obeyed that no index pair $(i,j)$ occurs more than once, that the dissimilarities are sorted, and that the tie blocks faithfully reflect ties in the sorted dissimilarities. We do need $i\neq j$, but it is not necessary that always $i>j$.

\sectionbreak

# Arguments

The smacofSS() function has the following arguments, with default values

1.  *theData*, an MDS data structure.\
2.  *ndim=2*, dimensionality of MDS analysis.
3.  *xinit=torgerson(theData, ndim)*, initial configuration, an *nobj* by *ndim* matrix.
4.  *weighted = FALSE*, TRUE/FALSE for weighted/unweighted least squares.
5.  *ordinal = FALSE*, FALSE or 0 for numerical, 1,2,3 for ordinal.
6.  *itmax = 1000*, maximum number of iterations.
7.  *eps = 1e-10*, if loss changes less than *eps*, stop.
8.  *digits = 10*, digits stress print if verbose is TRUE,
9.  *width = 12*, width stress print if verbose is TRUE,
10. *verbose = FALSE*, TRUE/FALSE print stress for each iteration to *stdout*.

In *ordinal* we use 1 for the primary approach to ties, 2 for the secondary approach, and 3 for the tertiary approach (@deleeuw_A_77). The default initial configuration is the classical scaling solution, with missing data imputed as average non-missing dissimilarities.

smacofSS() is a front end that reads the parameters of the problem and then calls one of four separate R programs. They are

1.  smacofSSUR(), unweighted numerical;
2.  smacofSSWR(), weighted numerical;
3.  smacofSSUO(), unweighted ordinal;
4.  smacofSSWO(), weighted ordinal.

Although using four separate programs involves duplicating some code it does allow us to make the programs smaller and faster. For example, we are not have to do weighted updates with unit weights in the unweighted case, and we don't have to branch each time for either ordinal and numerical.

In what follows "foo" can be "UR", "WR", "UO", or "WO". Each of the four R programs smacofSSfoo() calls a corresponding shared library, called smacofSSURfooEngine.so, which contains the compiled code of the C routine smacofSSfooEngine().

Each of the four R programs smacofSSfoo() can also be called directly, without using the smacofSS() frontend. Their arguments are the same as for smacofSS(), except that *weighted* and *ordinal* are not there, while smacofSSUO() and smacofSSWO() have the additional argument *ties*, equal to 1 (default), 2, or 3.

\sectionbreak

# Details

The C routines smacofSSfooEngine() by themselves are complete smacof MDS programs. It would be easy to write main programs in C that do the same job as the R frontend, and compile to stand-alone executables.

The C code uses the .C() calling conventions and is otherwise not dependent on R in any way. It is important that the .C() call from R is only executed one time in a smacofSS() job, when loading the shared library, and after that there is only compiled code running until the end of the job. In other words, everything done in R is either front-end or back-end, and is only done once. Earlier versions of the R/C program had R also managing the iterations. In each iteration there was a .C() call to update the configation and in the ordinal case an additional .C() call to update the pseudo-distances. This turned out to be unsatisfactory, because it did not give enough speedup compared to smacofSym().

If *ordinal* is TRUE the monotone regression in each iteration uses the C version of the *monotone()* algorithm of @busing_22. The *monotone()* algorithm is called in three separate C routines *primaryApproach()*, *secondaryApproach()*, and *tertiaryApproach()*, which in turn are called in each iteration by the smacofSSUOEngine() or smacofSSWOEngine() C routines.

The default initial configuration is computed by the *torgerson()* routine in *smacofUtils.R*. This is classical MDS, with the missing dissimilarities imputed using the average non-missing dissimilarity. The eigenvalues and eigenvectors are computed with *eigs-sym()* from the *RSpectra* package (@qiu_mei_24).

\sectionbreak

# Value

The list of objects returned by smacofSS() mimics, as much as possible, the list returned by smacofSym().

1.  *delta*, dissimilarities, vector of length $m$.
2.  *dhat*, final pseudo-distances, vector of length $m$.
3.  *confdist*, final distances, vector of length $m$.
4.  *conf*, final configuration, $n\times p$ matrix.
5.  *weightmat*, weights, vector of length $m$.
6.  *stress*, final stress.
7.  *ndim*, number of dimensions.
8.  *init*, initial configuration, $n\times p$ matrix..
9.  *niter*, number of iterations.
10. *nobj*, number of objects.
11. *iind*, row indices, vector of length $m$.
12. *jind*, column indices, vector of length $m$.
13. *weighted*, was the analysis weighted.
14. *ordinal*, was the analysis ordinal (and if so, which tie approach).

One important special case should be kept in mind. In the ordinal case with the primary approach to ties, the data are (potentially) reordered within tie blocks in each iteration. In each iteration we have to reorder iind, jind, and in the weighted case the weights. There is no need to reorder delta and the blocks, because the only ordering changes are within blocks. Ultimately this means that if smacofSS() returns a list *h*, then *h*$iind*, *h$jind, and in the weighted case *h\$weightmat* will be ordered differently from the corresponding columns in the MDS data structure. No reordering is going on using the secondary and tertiary approaches.

\sectionbreak

# Utilities

## Data Utilities

There are two functions in smacofDataUtilities.R

2.  makeMDSData(delta, weights = NULL). Returns MDS data structure from dist objects.
3.  fromMDSData(theData). Returns dist objects of dissimilarities and weights from MDS data structure.

## Auxilaries

There are two computational routines in smacofUtils.R. Ideally this should be C routines as well, but since the R versions are only used once in a job and rely on compiled code for their calculations there will be no major time loss.

The Moore-Penrose inverse of $V$ uses the regular inverse $V^+=(V+n^{-1}ee')^{-1}-n^{-1}ee'$, which is valid because the weights are assumed to be irreducible (@deleeuw_C_77). It is the only place in smacofSS() where a full symmetric matrix of order $n$ is used, which is another reason to look for a replacement. What is passed to C is the strictly lower-diagonal part of $V$ in a vector. The matrix multiplications in C by the $B$ matrix and the $V$ matrix do not need the diagonal elements.

1.  makeMPInverseV(theData). Returns vector with the lower diagonal of the Moore-Penrose inverse of $V$ matrix.
2.  torgerson(theData, ndim). Returns initial configuration in $nobj\times ndim$ matrix using classical MDS.

## Plotting

There are three plot routines in the file smacofPlots.R.

1.  smacofShepardPlot(h, main = "ShepardPlot", fitlines = TRUE, colline = "RED", colpoint = "BLUE", resolution = 100, lwd = 2, cex = 1, pch = 16)
2.  smacofConfigurationPlot(h, main = "ConfigurationPlot", labels = NULL, dim1 = 1, dim2 = 2, pch = 16, col = "RED", cex = 1)
3.  smacofDistDhatPlot(h, fitlines = TRUE, colline = "RED", colpoint = "BLUE", main = "Dist-Dhat Plot", cex = 1, lwd = 2, pch = 16)

The Shepard plot has the original dissimilarities on the horizontal axis, and both the pseudo-distances and the distances on the vertical axis. Pseudo-distances are plotted as points of color *colline*, and are connected by a line of color *colline*. Distances are plotted as points if color *colpoint*. If *fitlines* is TRUE then black vertical lines from the distance point to the pseudo-distance point are drawn.

The configuration plot plots two dimensions *dim1* and *dim2* of the configuration. If *labels* is NULL points are drawn with symbol *pch*, otherwise a vector of labels is used.

A DistDhat-plot has distances on the horizontal axis and pseudo-distances on the vertical axes. Points are drawn using symbol *pch* in color *colpoint*. The line through the origin with slope one is drawn in color *colline*. If *fitlines* is true then black lines from the points to their orthogonal projections on the line are drawn.

\sectionbreak

# Example Data Sets

There are a number of example data sets in the directory smacofSSData. They are mostly of the 20th century boomer type: small and collected from the aggregated judgments of human subjects. All data are available both as dist objects and as MDS data structures.

## Ekman Data

Similarity data between 14 colors from @ekman_54. Rating scale similarity judgments averaged over subjects, linearly converted to unit interval dissimilarities.

## Morse Data

Dissimilarity between the Morse codes of 36 letters and numbers from @rothkopf_57. Confusion probabilities transformed to dissimilarities.

## Gruijter Data

Dissimilarities of nine Dutch political parties in 1967, from @degruijter_67. Collected using the method of triads and averaged over 100 subjects.

## Wish Data

Rating scale imilarities between 12 nations, collected by @wish_71. Averaged over subects, subtracted from maximum scale value to form dissimilarities.

## Iris Data

Classical iris data from @anderson_36 via @fisher_36. Euclidean distances over four measurements on 150 irises.

\sectionbreak

# Comparisons

## Outcome

In this section we compare the output (final stress, number of iterations) of smacofSym() and smacofSS() using the Ekman and Morse data. Note that smacofSym() takes the square root of the final stress, following @kruskal_64a, so for comparison purposes we square it again. All runs are started with the two-dimensional torgerson solution and have the stop criteria *eps* equal to 1e-10 and *itmax* equal to 1000 (except when using the tertiary approach when *itmax* is 10000). In the weighted case the weights for Ekman are $w_{ij}=\delta_{ij}^2$ and those for Morse are $w_{ij}=\delta_{ij}^{-1}$.

```{r somedataE, echo = FALSE}
source("smacofSSData/ekmanData.R")
xinit <- torgerson(ekmanData, 2)
```

```{r compURE, cache = TRUE, echo = FALSE}
h1 <- smacofSym(ekman, init = xinit, type = "ratio", eps = 1e-10, itmax = 1000)
h2 <- smacofSSUR(ekmanData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, verbose = FALSE)
vecUR <- c(h1$stress ^ 2, h1$niter, h2$stress, h2$niter)
```

```{r compUO1E, cache = TRUE, echo = FALSE}
h1 <- smacofSym(ekman, init = xinit, type = "ordinal", ties = "primary", eps = 1e-10, itmax = 1000)
h2 <- smacofSSUO(ekmanData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 1, verbose = FALSE)
vecUO1 <- c(h1$stress ^ 2, h1$niter, h2$stress, h2$niter)
```

```{r compUO2E, cache = TRUE, echo = FALSE}
h1 <- smacofSym(ekman, init = xinit, type = "ordinal", ties = "secondary", eps = 1e-10, itmax = 1000)
h2 <- smacofSSUO(ekmanData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 2, verbose = FALSE)
vecUO2 <- c(h1$stress ^ 2, h1$niter, h2$stress, h2$niter)
```

```{r compUO3E, cache = TRUE, echo = FALSE}
h1 <- smacofSym(ekman, init = xinit, type = "ordinal", ties = "tertiary", eps = 1e-10, itmax = 10000)
h2 <- smacofSSUO(ekmanData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 10000, ties = 3, verbose = FALSE)
vecUO3 <- c(h1$stress ^ 2, h1$niter, h2$stress, h2$niter)
```

```{r compWRE, cache = TRUE, echo = FALSE}
h1 <- smacofSym(ekman, type = "ratio", eps = 1e-10, weightmat = ekman ^ 2, itmax = 1000)
h2 <- smacofSSWR(ekmanData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, verbose = FALSE)
vecWR <- c(h1$stress ^ 2, h1$niter, h2$stress, h2$niter)
```

```{r compWO1E, cache = TRUE, echo = FALSE}
h1 <- smacofSym(ekman, init = xinit, type = "ordinal", ties = "primary", weightmat = ekman ^ 2, eps = 1e-10, itmax = 1000)
h2 <- smacofSSWO(ekmanData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 1, verbose = FALSE)
vecWO1 <- c(h1$stress ^ 2, h1$niter, h2$stress, h2$niter)
```

```{r compWO2E, cache = TRUE, echo = FALSE}
h1 <- smacofSym(ekman, init = xinit, type = "ordinal", ties = "secondary", weightmat = ekman ^ 2, eps = 1e-10, itmax = 1000)
h2 <- smacofSSWO(ekmanData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 2, verbose = FALSE)
vecWO2 <- c(h1$stress ^ 2, h1$niter, h2$stress, h2$niter)
```

```{r compWO3E, cache = TRUE, echo = FALSE}
h1 <- smacofSym(ekman, init = xinit, type = "ordinal", ties = "tertiary", weightmat = ekman ^ 2, eps = 1e-10, itmax = 10000)
h2 <- smacofSSWO(ekmanData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 10000, ties = 3, verbose = FALSE)
vecWO3 <- c(h1$stress ^ 2, h1$niter, h2$stress, h2$niter)
```

```{r compkableE, echo = FALSE}
x <- matrix(c(vecUR, vecUO1, vecUO2, vecUO3, vecWR, vecWO1, vecWO2, vecWO3), 8, 4, byrow = TRUE)
r <- c("unweighted numerical", 
       "unweighted ordinal ties = 1",
       "unweighted ordinal ties = 2",
       "unweighted ordinal ties = 3",
       "weighted numerical", 
       "weighted ordinal ties = 1",
       "weighted ordinal ties = 2",
       "weighted ordinal ties = 3"
)
row.names(x) <- r
r <- c("Sym stress", "Sym niter", "SS stress", "SS niter")
colnames(x) <- r
kable(x, format = "simple", align = NULL, row.names = TRUE, caption = "Comparison smacofSym() and smacofSS() results Ekman data")
```

```{r somedata, echo = FALSE}
source("smacofSSData/morseData.R")
xinit <- torgerson(morseData, 2)
```

```{r compUR, cache = TRUE, echo = FALSE}
h1 <- smacofSym(morse, init = xinit, type = "ratio", eps = 1e-10, itmax = 1000)
h2 <- smacofSSUR(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, verbose = FALSE)
vecUR <- c(h1$stress ^ 2, h1$niter, h2$stress, h2$niter)
```

```{r compUO1, cache = TRUE, echo = FALSE}
h1 <- smacofSym(morse, init = xinit, type = "ordinal", ties = "primary", eps = 1e-10, itmax = 1000)
h2 <- smacofSSUO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 1, verbose = FALSE)
vecUO1 <- c(h1$stress ^ 2, h1$niter, h2$stress, h2$niter)
```

```{r compUO2, cache = TRUE, echo = FALSE}
h1 <- smacofSym(morse, init = xinit, type = "ordinal", ties = "secondary", eps = 1e-10, itmax = 1000)
h2 <- smacofSSUO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 2, verbose = FALSE)
vecUO2 <- c(h1$stress ^ 2, h1$niter, h2$stress, h2$niter)
```

```{r compUO3, cache = TRUE, echo = FALSE}
h1 <- smacofSym(morse, init = xinit, type = "ordinal", ties = "tertiary", eps = 1e-10, itmax = 1000)
h2 <- smacofSSUO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 3, verbose = FALSE)
vecUO3 <- c(h1$stress ^ 2, h1$niter, h2$stress, h2$niter)
```

```{r compWR, cache = TRUE, echo = FALSE}
h1 <- smacofSym(morse, type = "ratio", eps = 1e-10, weightmat = 1 / morse, itmax = 1000)
h2 <- smacofSSWR(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, verbose = FALSE)
vecWR <- c(h1$stress ^ 2, h1$niter, h2$stress, h2$niter)
```

```{r compWO1, cache = TRUE, echo = FALSE}
h1 <- smacofSym(morse, init = xinit, type = "ordinal", ties = "primary", weightmat = 1 / morse, eps = 1e-10, itmax = 1000)
h2 <- smacofSSWO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 1, verbose = FALSE)
vecWO1 <- c(h1$stress ^ 2, h1$niter, h2$stress, h2$niter)
```

```{r compWO2, cache = TRUE, echo = FALSE}
h1 <- smacofSym(morse, init = xinit, type = "ordinal", ties = "secondary", weightmat = 1 / morse, eps = 1e-10, itmax = 1000)
h2 <- smacofSSWO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 2, verbose = FALSE)
vecWO2 <- c(h1$stress ^ 2, h1$niter, h2$stress, h2$niter)
```

```{r compWO3, cache = TRUE, echo = FALSE}
h1 <- smacofSym(morse, init = xinit, type = "ordinal", ties = "tertiary", weightmat = 1 / morse, eps = 1e-10, itmax = 1000)
h2 <- smacofSSWO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 3, verbose = FALSE)
vecWO3 <- c(h1$stress ^ 2, h1$niter, h2$stress, h2$niter)
```

```{r compkable, echo = FALSE}
x <- matrix(c(vecUR, vecUO1, vecUO2, vecUO3, vecWR, vecWO1, vecWO2, vecWO3), 8, 4, byrow = TRUE)
r <- c("unweighted numerical", 
       "unweighted ordinal ties = 1",
       "unweighted ordinal ties = 2",
       "unweighted ordinal ties = 3",
       "weighted numerical", 
       "weighted ordinal ties = 1",
       "weighted ordinal ties = 2",
       "weighted ordinal ties = 3"
)
row.names(x) <- r
r <- c("Sym stress", "Sym niter", "SS stress", "SS niter")
colnames(x) <- r
kable(x, format = "simple", align = NULL, row.names = TRUE, caption = "Comparison smacofSym() and smacofSS() results Morse data")
```

The conclusion is clear. For the Ekman and Morse examples the results are identical.

## Time

The microbenchmark package (@mersmann_24) is really intended to time small pieces of code, not complete programs. Nevertheless we will use it to compare smacofSym() and smacofSS(). We again use the Ekman and Morse data with default options and use microbenchmark to find the median time for each of the runs.

```{r microbenchmark_numE, cache = TRUE, echo = FALSE}
h <- microbenchmark(
smacofSym(ekman, type = "ratio", eps = 1e-10, itmax = 1000),
smacofSSUR(ekmanData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, verbose = FALSE), control = list(order = "inorder"))
hss <- median(h$time[2 * (1:100)])
hsy <- median(h$time[-2 * (1:100)])
vecUR <- c(hss, hsy, hsy/hss)
```

```{r microbenchmark_ord1E, cache = TRUE, echo = FALSE}
h <- microbenchmark(
smacofSym(ekman, type = "ordinal", ties = "primary", eps = 1e-10, itmax = 1000),
smacofSSUO(ekmanData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 1, verbose = FALSE), control = list(order = "inorder"))
hss <- median(h$time[2 * (1:100)])
hsy <- median(h$time[-2 * (1:100)])
vecUO1 <- c(hss, hsy, hsy/hss)
```

```{r microbenchmark_ord2E, cache = TRUE, echo = FALSE}
h <- microbenchmark(
smacofSym(ekman, type = "ordinal", ties = "secondary", eps = 1e-10, itmax = 1000),
smacofSSUO(ekmanData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 2, verbose = FALSE), control = list(order = "inorder"))
hss <- median(h$time[2 * (1:100)])
hsy <- median(h$time[-2 * (1:100)])
vecUO2 <- c(hss, hsy, hsy/hss)
```

```{r microbenchmark_ord3E, cache = TRUE, echo = FALSE}
h <- microbenchmark(
smacofSym(ekman, type = "ordinal", ties = "tertiary", eps = 1e-10, itmax = 10000),
smacofSSUO(ekmanData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 10000, ties = 3, verbose = FALSE), control = list(order = "inorder"))
hss <- median(h$time[2 * (1:100)])
hsy <- median(h$time[-2 * (1:100)])
vecUO3 <- c(hss, hsy, hsy/hss)
```

```{r wgthnumE, cache = TRUE, echo = FALSE}
h <- microbenchmark(
smacofSym(ekman, type = "ratio", eps = 1e-10, weightmat = ekman ^ 2, itmax = 1000),
smacofSSWR(ekmanData, ndim = 2,  xinit = xinit, eps = 1e-10, itmax = 1000, verbose = FALSE), control = list(order = "inorder"))
hss <- median(h$time[2 * (1:100)])
hsy <- median(h$time[-2 * (1:100)])
vecWR <- c(hss, hsy, hsy/hss)
```

```{r wgthord1E, cache = TRUE, echo = FALSE}
h <- microbenchmark(
smacofSym(ekman, type = "ordinal", ties = "primary", eps = 1e-10, weightmat = ekman ^ 2, itmax = 1000),
smacofSSWO(ekmanData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 1, verbose = FALSE), control = list(order = "inorder"))
hss <- median(h$time[2 * (1:100)])
hsy <- median(h$time[-2 * (1:100)])
vecWO1 <- c(hss, hsy, hsy/hss)
```

```{r wgthord2E, cache = TRUE, echo = FALSE}
h <- microbenchmark(
smacofSym(ekman, type = "ordinal", ties = "secondary", eps = 1e-10, weightmat = ekman ^ 2, itmax = 1000),
smacofSSWO(
  ekmanData,
  ndim = 2,
  xinit = xinit,
  eps = 1e-10,
  itmax = 1000,
  ties = 2,
  verbose = FALSE
), control = list(order = "inorder"))
hss <- median(h$time[2 * (1:100)])
hsy <- median(h$time[-2 * (1:100)])
vecWO2 <- c(hss, hsy, hsy/hss)
```

```{r wgthord3E, cache = TRUE, echo = FALSE}
h <- microbenchmark(
smacofSym(ekman, type = "ordinal", ties = "tertiary", eps = 1e-10, weightmat = ekman ^ 2, itmax = 10000),
smacofSSWO(ekmanData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 10000, ties = 3, verbose = FALSE), control = list(order = "inorder"))
hss <- median(h$time[2 * (1:100)])
hsy <- median(h$time[-2 * (1:100)])
vecWO3 <- c(hss, hsy, hsy/hss)
```

```{r timekableE, echo = FALSE}
x <- matrix(c(vecUR, vecUO1, vecUO2, vecUO3, vecWR, vecWO1, vecWO2, vecWO3), 8, 3, byrow = TRUE)
r <- c("unweighted numerical", 
       "unweighted ordinal ties = 1",
       "unweighted ordinal ties = 2",
       "unweighted ordinal ties = 3",
       "weighted numerical", 
       "weighted ordinal ties = 1",
       "weighted ordinal ties = 2",
       "weighted ordinal ties = 3"
)
row.names(x) <- r
r <- c("SS time", "Sym time", "ratio Sym/SS")
colnames(x) <- r
kable(x, format = "simple", align = NULL, row.names = TRUE, caption = "Comparison smacofSym() and smacofSS() running times Ekman Data")
```

The entries in the table for the tertiary approach are suspect, because it uses a huge number of iterations to
arrive at a perfect solution. In many of the microbenchmark runs it may actually use the full 10000 iterations.
From the better conditioned numerical and ordinalsolutions we see that smacofSS is between 4.5 and 56.7 times
as fast as smacofSym. The improvment is largest in the unweighted analyses.

```{r microbenchmark_num, cache = TRUE, echo = FALSE}
h <- microbenchmark(
smacofSym(morse, type = "ratio", eps = 1e-10, itmax = 1000),
smacofSSUR(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, verbose = FALSE), control = list(order = "inorder"))
hss <- median(h$time[2 * (1:100)])
hsy <- median(h$time[-2 * (1:100)])
vecUR <- c(hss, hsy, hsy/hss)
```

```{r microbenchmark_ord1, cache = TRUE, echo = FALSE}
h <- microbenchmark(
smacofSym(morse, type = "ordinal", ties = "primary", eps = 1e-10, itmax = 1000),
smacofSSUO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 1, verbose = FALSE), control = list(order = "inorder"))
hss <- median(h$time[2 * (1:100)])
hsy <- median(h$time[-2 * (1:100)])
vecUO1 <- c(hss, hsy, hsy/hss)
```

```{r microbenchmark_ord2, cache = TRUE, echo = FALSE}
h <- microbenchmark(
smacofSym(morse, type = "ordinal", ties = "secondary", eps = 1e-10, itmax = 1000),
smacofSSUO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 2, verbose = FALSE), control = list(order = "inorder"))
hss <- median(h$time[2 * (1:100)])
hsy <- median(h$time[-2 * (1:100)])
vecUO2 <- c(hss, hsy, hsy/hss)
```

```{r microbenchmark_ord3, cache = TRUE, echo = FALSE}
h <- microbenchmark(
smacofSym(morse, type = "ordinal", ties = "tertiary", eps = 1e-10, itmax = 1000),
smacofSSUO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 3, verbose = FALSE), control = list(order = "inorder"))
hss <- median(h$time[2 * (1:100)])
hsy <- median(h$time[-2 * (1:100)])
vecUO3 <- c(hss, hsy, hsy/hss)
```

```{r wgthnum, cache = TRUE, echo = FALSE}
h <- microbenchmark(
smacofSym(morse, type = "ratio", eps = 1e-10, weightmat = 1 / morse, itmax = 1000),
smacofSSWR(morseData, ndim = 2,  xinit = xinit, eps = 1e-10, itmax = 1000, verbose = FALSE), control = list(order = "inorder"))
hss <- median(h$time[2 * (1:100)])
hsy <- median(h$time[-2 * (1:100)])
vecWR <- c(hss, hsy, hsy/hss)
```

```{r wgthord1, cache = TRUE, echo = FALSE}
h <- microbenchmark(
smacofSym(morse, type = "ordinal", ties = "primary", eps = 1e-10, weightmat = 1 / morse, itmax = 1000),
smacofSSWO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 1, verbose = FALSE), control = list(order = "inorder"))
hss <- median(h$time[2 * (1:100)])
hsy <- median(h$time[-2 * (1:100)])
vecWO1 <- c(hss, hsy, hsy/hss)
```

```{r wgthord2, cache = TRUE, echo = FALSE}
h <- microbenchmark(
smacofSym(morse, type = "ordinal", ties = "secondary", eps = 1e-10, weightmat = 1 / morse, itmax = 1000),
smacofSSWO(
  morseData,
  ndim = 2,
  xinit = xinit,
  eps = 1e-10,
  itmax = 1000,
  ties = 2,
  verbose = FALSE
), control = list(order = "inorder"))
hss <- median(h$time[2 * (1:100)])
hsy <- median(h$time[-2 * (1:100)])
vecWO2 <- c(hss, hsy, hsy/hss)
```

```{r wgthord3, cache = TRUE, echo = FALSE}
h <- microbenchmark(
smacofSym(morse, type = "ordinal", ties = "tertiary", eps = 1e-10, weightmat = 1 / morse, itmax = 1000),
smacofSSWO(morseData, ndim = 2, xinit = xinit, eps = 1e-10, itmax = 1000, ties = 3, verbose = FALSE), control = list(order = "inorder"))
hss <- median(h$time[2 * (1:100)])
hsy <- median(h$time[-2 * (1:100)])
vecWO3 <- c(hss, hsy, hsy/hss)
```

```{r timekable, echo = FALSE}
x <- matrix(c(vecUR, vecUO1, vecUO2, vecUO3, vecWR, vecWO1, vecWO2, vecWO3), 8, 3, byrow = TRUE)
r <- c("unweighted numerical", 
       "unweighted ordinal ties = 1",
       "unweighted ordinal ties = 2",
       "unweighted ordinal ties = 3",
       "weighted numerical", 
       "weighted ordinal ties = 1",
       "weighted ordinal ties = 2",
       "weighted ordinal ties = 3"
)
row.names(x) <- r
r <- c("SS time", "Sym time", "ratio Sym/SS")
colnames(x) <- r
kable(x, format = "simple", align = NULL, row.names = TRUE, caption = "Comparison smacofSym() and smacofSS() running times Morse data")
```

```{r iristime, cache = TRUE, echo = FALSE, eval= FALSE}
source("smacofSSData/irisData.R")
h1 <- microbenchmark(
smacofSym(irisDist, eps = 1e-10, verbose = FALSE, type = "ratio", itmax = 1000),
smacofSSUR(irisData, verbose = FALSE))
h2 <- microbenchmark(
smacofSym(irisDist, eps = 1e-10, verbose = FALSE, type = "ordinal", ties = "primary", itmax = 1000),
smacofSSUO(irisData, verbose = FALSE))
```

We see that smacofSS() is four to eighteen times faster than smacofSym(). The difference is largest in the numerical case, and it is also larger for unweighted than for weighted. Strangely enough for the ordinal options the weighted case generally seems faster than the corresponding non-weighted case. We also see that primary is faster than secondary and secondary is faster than tertiary. Again, there is a need for some tinkering with the code to see if these relations are real and stable or are a result of poor coding and various artefacts. Note that we have used microbenchmark in such a way that smacofSS() is always run after the corresponding smacofSym(), and that the eight different basic combinations or weighted and ordinal are always run in the same order.

\sectionbreak

# Real Example

To show some plots we repeat eight possible analyses using the Ekman and Morse data. The number of iterations and the final stress have already been reported previously in the comparisons section. Both data sets have a fairly large number of ties, so we expect the choice of the ties approach to have some effect.

The next eight pages have Shepard plots and DistDhat plots for each of the four unweighted analyses. No plots are given for the weighted analyses, because they would illustrate essentially the same points. We made the plots large so they show some detail. Shepard plots have *fitlines* equal to TRUE, DistDhat plots have *fitlines* equal to TRUE for the Ekman data and FALSE for the Morse data. The sum of the squared lengths of the vertical fitlines in the Shepard plots is the stress. In the DistDhat plots the sum of squares of distances of the points to their orthogonal projections on the line is also the stress. Thus we can see from the plots where the largest residuals are, although the plot does not show which pair of points the fitlines correspond with. That information can easily be obtained from the numerical output.

The Ekman example has an exceptionally good fit, even in the numerical case. Still,allowing for ordinal transformations gives a major improvement. Especially the DistDhat plots in the ordinal case show the different ways of handling tie blocks. The tertiary approach gives what is essentially a perfect fit, but the Shepard plot shows that in order to achieve this deviations from monotonicity are required.

The Morse example has a bad numerical fit, and the improvements by the oidinal options are huge. There are
no fitlines in the DistDhat plots, because that would mainly result in big black blobs. As in the Ekman
example the tertiary approach gives close to perfect fit, at the cost of many deviations from monotonicity.

```{r ekmanall, echo = FALSE, cache = TRUE}
source("smacofSSData/ekmanData.R")
xinit <- torgerson(ekmanData, 2)
hUR <- smacofSS(ekmanData, xinit = xinit, verbose = FALSE)
hUO1 <- smacofSS(ekmanData, xinit = xinit, ordinal = 1, verbose = FALSE)
hUO2 <- smacofSS(ekmanData, xinit = xinit, ordinal = 2, verbose = FALSE)
hUO3 <- smacofSS(ekmanData, xinit = xinit, ordinal = 3, verbose = FALSE)
hWR <- smacofSS(ekmanData, xinit = xinit, weighted = TRUE, verbose = FALSE)
hWO1 <- smacofSS(ekmanData, xinit = xinit, ordinal = 1, weighted = TRUE, verbose = FALSE)
hWO2 <- smacofSS(ekmanData, xinit = xinit, ordinal = 2, weighted = TRUE, verbose = FALSE)
hWO3 <- smacofSS(ekmanData, xinit = xinit, ordinal = 3, weighted = TRUE, verbose = FALSE)
```

\sectionbreak

```{r plotekman, fig.align = "center", fig.width = 8, fig.height = 8, echo = FALSE}
par(pty="s")
smacofShepardPlot(hUR, main = "Shepard Plot, Ekman Data, Unweighted, Numerical")
smacofShepardPlot(hUO1, main = "Shepard Plot, Ekman Data, Unweighted, Ordinal, Primary")
smacofShepardPlot(hUO2, main = "Shepard Plot, Ekman Data, Unweighted, Ordinal, Secondary")
smacofShepardPlot(hUO3, main = "Shepard Plot, Ekman Data, Unweighted, Ordinal, Tertiary")
smacofDistDhatPlot(hUR, main = "DistDhat Plot, Ekman Data, Unweighted, Numerical")
smacofDistDhatPlot(hUO1, main = "DistDhat Plot, Ekman Data, Unweighted, Ordinal, Primary")
smacofDistDhatPlot(hUO2, main = "DistDhat Plot, Ekman Data, Unweighted, Ordinal, Secondary")
smacofDistDhatPlot(hUO3,  main = "DistDhat Plot, Ekman Data, Unweighted, Ordinal, Tertiary")
```

```{r morseall, echo = FALSE, cache = TRUE}
source("smacofSSData/morseData.R")
xinit <- torgerson(morseData, 2)
hUR <- smacofSS(morseData, xinit = xinit, verbose = FALSE)
hUO1 <- smacofSS(morseData, xinit = xinit, ordinal = 1, verbose = FALSE)
hUO2 <- smacofSS(morseData, xinit = xinit, ordinal = 2, verbose = FALSE)
hUO3 <- smacofSS(morseData, xinit = xinit, ordinal = 3, verbose = FALSE)
hWR <- smacofSS(morseData, xinit = xinit, weighted = TRUE, verbose = FALSE)
hWO1 <- smacofSS(morseData, xinit = xinit, ordinal = 1, weighted = TRUE, verbose = FALSE)
hWO2 <- smacofSS(morseData, xinit = xinit, ordinal = 2, weighted = TRUE, verbose = FALSE)
hWO3 <- smacofSS(morseData, xinit = xinit, ordinal = 3, weighted = TRUE, verbose = FALSE)
```

\sectionbreak

```{r plotmorse, fig.align = "center", fig.width = 8, fig.height = 8, echo = FALSE}
par(pty="s")
smacofShepardPlot(hUR, main = "Shepard Plot, Morse Data, Unweighted, Numerical")
smacofShepardPlot(hUO1, main = "Shepard Plot, Morse Data, Unweighted, Ordinal, Primary")
smacofShepardPlot(hUO2, main = "Shepard Plot, Morse Data, Unweighted, Ordinal, Secondary")
smacofShepardPlot(hUO3, main = "Shepard Plot, Morse Data, Unweighted, Ordinal, Tertiary")
smacofDistDhatPlot(hUR, fitlines = FALSE, main = "DistDhat Plot, Morse Data, Unweighted, Numerical")
smacofDistDhatPlot(hUO1, fitlines = FALSE, main = "DistDhat Plot, Morse Data, Unweighted, Ordinal, Primary")
smacofDistDhatPlot(hUO2, fitlines = FALSE, main = "DistDhat Plot, Morse Data, Unweighted, Ordinal, Secondary")
smacofDistDhatPlot(hUO3, fitlines = FALSE, main = "DistDhat Plot, Morse Data, Unweighted, Ordinal, Tertiary")
```

\sectionbreak

# References
