---
title: Yet Another Smacof
  - Square Symmetric Case
author: 
      name: Jan de Leeuw
      orcid: 0000-0003-1420-1797
      email: jan@deleeuwpdx.net
      affiliation: 
        - name: University of California Los Angeles
          city: Los Angeles
          state: CA
          url: www.ucla.edu
      license: "CC0"
date: last-modified
date-format: long
bibliography: [mypubs.bib, total.bib]
number-sections: true
pdf-engine: lualatex
keep-tex: true
format:
   pdf:
    fontsize: 12pt
    include-in-header: 
     - preamble.tex
    keep-tex: true
    link-citations: true
    documentclass: scrartcl
    number-sections: true
   html:
    fontsize: 12pt
    include-in-header: 
     - preamble.css
    keep-md: true
    number-sections: true
toc: true
toc-depth: 3
editor: source
papersize: letter
graphics: true
link-citations: true
mainfont: Times New Roman
abstract: We rewrite the metric/nonmetric and weighted/unweighted versions of the smacof program for   square symmetric data as four monolithic C programs, with R used for taking care of the setup, the    I/O, and of issuing a single call to .C() to start the computations. This makes the programs twenty to fifty times as fast (for our examples) as the smacofSym() function from the smacof package.
---

```{r loadpackages, echo = FALSE}
suppressPackageStartupMessages(library(knitr, quietly = TRUE))
suppressPackageStartupMessages(library(tinytex, quietly = TRUE))
suppressPackageStartupMessages(library(microbenchmark, quietly = TRUE))
suppressPackageStartupMessages(library(smacof, quietly = TRUE))
```

```{r loadsourses, echo = FALSE}
source("smacofUtils.R")
source("smacofSSUR.R")
source("smacofSSWR.R")
source("smacofSSUO.R")
source("smacofSSWO.R")
```

```{r turnoff, echo = FALSE}
options(warn = -1)
```

**Note:** This is a working manuscript which will be expanded/updated
frequently. All suggestions for improvement are welcome. All Rmd, tex,
html, pdf, R, and C files are in the public domain. Attribution will be
appreciated, but is not required. The files can be found at
<https://github.com/deleeuw> 

\sectionbreak

# Introduction

The data in MDS is information about the non-negative *dissimilarities* $\delta_{ij}$ between pairs of objects $(i,j)$ from a set of $n$ objects, together with positive *weights* $w_{ij}$ that indicate the importance or precision of dissimilarity $\delta_{ij}$. In (unconstrained, least squares, square, symmetric, Euclidean, $p-$dimensional) MDS we
want to map the objects into points in $p$-dimensional Euclidean space in such a way that the distances
$d_{ij}$ between the points approximate the dissimilarities $\delta_{ij$. 

If the dissimilarities are known numbers the MDS problem is *metric*, if 

Suppose $I_n=\{1,2,\cdots,n\}$ and $\mathcal{K}$ is a subset of $I_n\times I_n$ of size $m$. For all with $(i,j)\in\mathcal{K}$
we have $i>j$.
\begin{equation}
\sigma(X,\Delta):=\frac{\sum_{(i,j)\in\mathcal{K}}w_{ij}(\delta_{ij}-d_{ij}(X))^2}{\sum_{(i,j)\in\mathcal{K}}w_{ij}\delta_{ij}^2}.
\label{eq-stressdef}
\end{equation}
In \eqref{eq-stressdef}

* $\delta_{ij}$ are $m$ non-negative *pseudo-distances*;
* $w_{ij}$ are $m$ positive *weights*;
* $X$ is an $n\times p$ *configuration matrix*, with coordinates of $n$ *points* in $\mathbb{R}^p$;
* $d_{ij}(X)$ are the (Euclidean) *distances* between the rows of the configuration matrix.

Thus
\begin{equation}
d_{ij}(X):=\sqrt{\sum_{s=1}^p(x_{is}-x_{js})^2}.\label{eq-distdef}
\end{equation}

The (unconstrained, least squares, square, symmetric, Euclidean, $p-$dimensional) MDS problem is to minimize $\sigma$ of \eqref{eq-stressdef} over all $n\times p$ configurations and over a set $\mathcal{D}\in\mathbb{R}^m_+$ of non-negative  
pseudo-distances. 
An MDS problem is *unweighted* if all $w_{ij}$ are equal, otherwise it is *weighted*. An MDS problem is *metric* if
the set $\mathcal{D}$ of dissimilarities is a singleton, otherwise it is *non-metric*.


# MDS Data Structure

Start with an object of class *dist* containing dissimilarities. Here is a small example of order four.
```{r small, echo = FALSE}
small <- as.dist(matrix(
  c(0, 1, 3, 2, 1, 0, 1, 3, 3, 1, 0, 1, 2, 3, 1, 0), 4, 4))
print(small)
```
Turn this into MDS data with the utility *makeMDSData()*.
```{r smalldata}
smallData <- makeMDSData(small)
print(smallData)
```
Note that the data in column *delta* are sorted, and that *blocks* has tie blocks. This is always
the case, even for a metric MDS, because the information will be useful for plotting routines
later on. Also, the *weights* are always there in some form, even if our MDS analysis will be
unweighted.

*makeMDSData()* can handle missing data and nontrivial weights. If our example is
```{r smallmis, echo = FALSE}
smallmis <- small
smallmis[1] <- smallmis[3] <- NA
print(smallmis) 
```
and we add weights, also of class *dist*,
```{r smallweights, echo = FALSE}
weights <- 1 / small
weights[6] <- 0
print(weights)
```
then our MDS data becomes
```{r smalldatamis}
smallData <- makeMDSData(smallmis, weights)
print(smallData)
```
Missing data are coded as zero weights, or as dissimilarities and/or weights that are *NA*.
Zero dissimilarities do not indicate missing data.

These conventions make it possible to also handle rectangular off-diagonal data, such as
```{r rect, echo = FALSE}
m <- matrix(c(1, 3, 1, 1, 2, 1, 3, 3, 3, 1, 2, 3), 4, 3)
rect <- matrix(0, 7, 7)
rect[1:4, 5:7] <- m
rect <- as.dist(rect + t(rect))
weights <- matrix(0, 7, 7)
weights[1:4, 5:7] <- 1
weights <- as.dist(weights + t(weights))
print(rect)
print(weights)
```
Now *makeMDSData* gives
```{r rectdata, echo = FALSE}
rectData <- makeMDSData(rect, weights)
print(rectData)
```
Handling rectangular data with square symmetric MDS is consequently possible, but it is inefficient
and better to use the smacof programs specifically intended for rectangular data.

It is of course also possible to construct MDS data sets of this form in other ways, and to edit
MDS data sets. As long as the conventions are obeyed that no index pair $(i,j)$ occurs more than once, that the dissimilarities are sorted, and that the tie blocks faithfully reflect ties in the sorted dissimilarities. We do need $i\neq j$, but it is not necessary that always $i>j$.

# Arguments

The *smacofSS* function has the following arguments.

Four functions

1. *theData*, an MDS data structure.  
2. *ndim*, dimensionality of MDS analysis.
3. *xold*, initial configuration, an *nobj* by *ndim* matrix.
4. *weighted*, TRUE/FALSE for weighted/unweighted least squares.
5. *ordinal*, TRUE/FALSE for ordinal/numerical.
6. *ties*, primary (1), secondary(2), or tertiary (3) approaches. 
7. *itmax*, maximum number of iterations.
8. *eps*, if loss changes less than *eps*, stop.
9. *verbose*, TRUE/FALSE print iteration info to *stdout*.

# Details


 The terminology in
*ties* refers to @deleeuw_A_77.

# Value

A list with elements

1.  *data*, the input data structure, unmodified;
2.  *conf*, the final configuration, an *nobj* by *ndim* matrix;
3.  *loss*, the final loss function value;
4.  *dist*, the final distances, an object of class *dist*;
5.  *dhat*, the final disparities (if *ordinal* is FALSE these
  are just normalized dissimilarities);
6.  *itel*, the number of iterations.

# Computational Details

*smacofSS()* is a front end that reads the parameters of the problem and then calls
one of four separate R programs. They are 

1. *smacofSSUR()*, unweighted numerical;
2. *smacofSSWR()*, weighted numerical;
3. *smacofSSUO()*, unweighted ordinal;
4. *smacofSSWO()*, weighted ordinal.

Although using four separate programs obviously involves duplicating some code it does
allow us to make the programs smaller and faster. For example, we are not forced to do
weighted updates with unit weights in the unweighted case.

*smacofSS()* is written using a combination of R and C. The smacof update in each iteration
is handled in C, with separate routines *smacofStepUnweighted()* and *smacofStepWeighted()*.


If *ordinal* is TRUE the monotone regression in each iteration
uses the C version of the *monotone()* algorithm of @busing_22. The *monotone()*
algorithm is imbedded in three separate C routines *primaryApproach()*, *secondaryApproach()*,
and *tertiaryApproach()*. The C code uses the .C()
calling conventions and is otherwise not dependent on R in any way.

Initial configurations can be chosen in many ways. Recommended is to use the
*torgerson()* routine in *smacofUtils.R*. This is classical MDS, with the missing
dissimilarities imputed using the average non-missing dissimilarity. The
eigenvalues and eigenvectors are computed with *eigs-sym()* from the
*RSpectra* package (@qiu_mei_24).



\sectionbreak

# Comparisons

## Outcome

```{r}
xinit <- torgerson(morseData, 2)
```

```{r compUR, cache = FALSE, echo = FALSE}
h1 <- smacofSym(morse, init = xinit, type = "ratio", eps = 1e-10, itmax = 1000)
h2 <- smacofSSUR(morseData, ndim = 2, xold = xinit, eps = 1e-10, itmax = 1000, verbose = FALSE)
cat(formatC(h1$stress ^ 2, digits = 10, width = 15, format = "f"),
    formatC(h1$niter, width = 6, format = "d"),
    formatC(h2$loss, digits = 10, width = 15, format = "f"),
    formatC(h2$itel, width = 6, format = "d"),"\n")
```

```{r compUO1, cache = FALSE, echo = FALSE}
h1 <- smacofSym(morse, type = "ordinal", ties = "primary", eps = 1e-10, itmax = 1000)
h2 <- smacofSSUO(morseData, ndim = 2, xold = xinit, eps = 1e-10, itmax = 1000, ties = 1, verbose = FALSE)
cat(formatC(h1$stress ^ 2, digits = 10, width = 15, format = "f"),
    formatC(h1$niter, width = 6, format = "d"),
    formatC(h2$loss, digits = 10, width = 15, format = "f"),
    formatC(h2$itel, width = 6, format = "d"),"\n")
```
```{r compUO2, cache = FALSE, echo = FALSE}
h1 <- smacofSym(morse, type = "ordinal", ties = "secondary", eps = 1e-10, itmax = 1000)
h2 <- smacofSSUO(morseData, ndim = 2, xold = xinit, eps = 1e-10, itmax = 1000, ties = 2, verbose = FALSE)
cat(formatC(h1$stress ^ 2, digits = 10, width = 15, format = "f"),
    formatC(h1$niter, width = 6, format = "d"),
    formatC(h2$loss, digits = 10, width = 15, format = "f"),
    formatC(h2$itel, width = 6, format = "d"),"\n")
```
```{r compUO3, cache = FALSE, echo = FALSE}
h1 <- smacofSym(morse, type = "ordinal", ties = "tertiary", eps = 1e-10, itmax = 1000)
h2 <- smacofSSUO(morseData, ndim = 2, xold = xinit, eps = 1e-10, itmax = 1000, ties = 3, verbose = FALSE)
cat(formatC(h1$stress ^ 2, digits = 10, width = 15, format = "f"),
    formatC(h1$niter, width = 6, format = "d"),
    formatC(h2$loss, digits = 10, width = 15, format = "f"),
    formatC(h2$itel, width = 6, format = "d"),"\n")
```

```{r compWR, cache = FALSE, echo = FALSE}
h1 <- smacofSym(morse, type = "ratio", eps = 1e-10, weightmat = 1 / morse, itmax = 1000)
h2 <- smacofSSWR(morseData, ndim = 2, xold = xinit, eps = 1e-10, itmax = 1000, verbose = FALSE)
cat(formatC(h1$stress ^ 2, digits = 10, width = 15, format = "f"),
    formatC(h1$niter, width = 6, format = "d"),
    formatC(h2$loss, digits = 10, width = 15, format = "f"),
    formatC(h2$itel, width = 6, format = "d"),"\n")
```

```{r compWO1, cache = FALSE, echo = FALSE}
h1 <- smacofSym(morse, type = "ordinal", ties = "primary", weightmat = 1 / morse, eps = 1e-10, itmax = 1000)
h2 <- smacofSSWO(morseData, ndim = 2, xold = xinit, eps = 1e-10, itmax = 1000, ties = 1, verbose = FALSE)
cat(formatC(h1$stress ^ 2, digits = 10, width = 15, format = "f"),
    formatC(h1$niter, width = 6, format = "d"),
    formatC(h2$loss, digits = 10, width = 15, format = "f"),
    formatC(h2$itel, width = 6, format = "d"),"\n")
```
```{r compWO2, cache = FALSE, echo = FALSE}
h1 <- smacofSym(morse, type = "ordinal", ties = "secondary", weightmat = 1 / morse, eps = 1e-10, itmax = 1000)
h2 <- smacofSSWO(morseData, ndim = 2, xold = xinit, eps = 1e-10, itmax = 1000, ties = 2, verbose = FALSE)
hh <- c(h1$stress, h1$niter, h2$loss, h2$itel)
cat(formatC(h1$stress ^ 2, digits = 10, width = 15, format = "f"),
    formatC(h1$niter, width = 6, format = "d"),
    formatC(h2$loss, digits = 10, width = 15, format = "f"),
    formatC(h2$itel, width = 6, format = "d"),"\n")
```
```{r compWO3, cache = FALSE, echo = FALSE}
h1 <- smacofSym(morse, type = "ordinal", ties = "tertiary", weightmat = 1 / morse, eps = 1e-10, itmax = 1000)
h2 <- smacofSSWO(morseData, ndim = 2, xold = xinit, eps = 1e-10, itmax = 1000, ties = 3, verbose = FALSE)
cat(formatC(h1$stress ^ 2, digits = 10, width = 15, format = "f"),
    formatC(h1$niter, width = 6, format = "d"),
    formatC(h2$loss, digits = 10, width = 15, format = "f"),
    formatC(h2$itel, width = 6, format = "d"),"\n")
```

## Time

```{r microbenchmark_num, cache = TRUE, echo = FALSE}
microbenchmark(
smacofSym(morse, type = "ratio", eps = 1e-10, itmax = 1000),
smacofSSUR(morseData, ndim = 2, xold = xinit, eps = 1e-10, itmax = 1000, verbose = FALSE), control = list(order = "inorder"))
```

```{r microbenchmark_ord1, cache = TRUE, echo = FALSE}
microbenchmark(
smacofSym(morse, type = "ordinal", ties = "primary", eps = 1e-10, itmax = 1000),
smacofSSUO(morseData, ndim = 2, xold = xinit, eps = 1e-10, itmax = 1000, ties = 1, verbose = FALSE), control = list(order = "inorder"))
```
```{r microbenchmark_ord2, cache = TRUE, echo = FALSE}
microbenchmark(
smacofSym(morse, type = "ordinal", ties = "secondary", eps = 1e-10, itmax = 1000),
smacofSSUO(morseData, ndim = 2, xold = xinit, eps = 1e-10, itmax = 1000, ties = 2, verbose = FALSE), control = list(order = "inorder"))
```
```{r microbenchmark_ord3, cache = TRUE, echo = FALSE}
microbenchmark(
smacofSym(morse, type = "ordinal", ties = "tertiary", eps = 1e-10, itmax = 1000),
smacofSSUO(morseData, ndim = 2, xold = xinit, eps = 1e-10, itmax = 1000, ties = 3, verbose = FALSE), control = list(order = "inorder"))
```



```{r wgthnum, cache = TRUE, echo = FALSE}
microbenchmark(
smacofSym(morse, type = "ratio", eps = 1e-10, weightmat = 1 / morse, itmax = 1000),
smacofSSWR(morseData, ndim = 2,  xold = xinit, eps = 1e-10, itmax = 1000, verbose = FALSE), control = list(order = "inorder"))
```

```{r wgthord1, cache = TRUE, echo = FALSE}
microbenchmark(
smacofSym(morse, type = "ordinal", ties = "primary", eps = 1e-10, weightmat = 1 / morse, itmax = 1000),
smacofSSWO(morseData, ndim = 2, xold = xinit, eps = 1e-10, itmax = 1000, ties = 1, verbose = FALSE), control = list(order = "inorder"))
```

```{r wgthord2, cache = TRUE, echo = FALSE}
microbenchmark(
smacofSym(morse, type = "ordinal", ties = "secondary", eps = 1e-10, weightmat = 1 / morse, itmax = 1000),
smacofSSWO(
  morseData,
  ndim = 2,
  xold = xinit,
  eps = 1e-10,
  itmax = 1000,
  ties = 2,
  verbose = FALSE
), control = list(order = "inorder"))
```
```{r wgthord3, cache = TRUE, echo = TRUE}
microbenchmark(
smacofSym(morse, type = "ordinal", ties = "tertiary", eps = 1e-10, weightmat = 1 / morse, itmax = 1000),
smacofSSWO(morseData, ndim = 2, xold = xinit, eps = 1e-10, itmax = 1000, ties = 3, verbose = FALSE), control = list(order = "inorder"))
```
```{r table, echo = FALSE}
rnames = c(
"ratio, unweighted",
"ordinal, unweighted,ties = primary",
"ordinal, unweighted, ties = secondary",
"ordinal, unweighted, ties = tertiary"
)
x = matrix(c(
15156.388,850.504, 15156.38/850.504,
14956.0825, 382.8785, 14956.0825/382.8785,
9977.2885, 342.2475, 9977.2885/342.2475,
24522.2640, 365.9045, 24522.2640/365.9045
), 4, 3, byrow = TRUE)
x <- data.frame(rnames, as.data.frame(x))
kable(x, digits = 4, row.names = FALSE, col.names = c("options", "smacofSym", "smacofSS", "ratio"))
```

```{r iristime, cache = TRUE}
microbenchmark(
smacofSym(irisDist, eps = 1e-10, verbose = FALSE, type = "ratio", itmax = 1000),
smacofSSUR(irisData, verbose = FALSE))
```
# References